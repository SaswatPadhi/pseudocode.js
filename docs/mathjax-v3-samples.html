<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>pseudocode.js Samples with MathJax</title>

    <!-- Setup MathJax -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$','$'], ['\\(','\\)']],
                displayMath: [['$$','$$'], ['\\[','\\]']],
                processEscapes: true,
                processEnvironments: true,
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"
            integrity="sha256-Cm3tWrvOEzMWWN0jnzQ4Kr0GSSx0txth6MqoES7FX6U="
            crossorigin="anonymous" referrerpolicy="no-referrer">
    </script>

    <!-- Pseudocode -->
    <link rel="stylesheet" href="pseudocode.css" type="text/css">
    <script src="pseudocode.js" type="text/javascript"></script>
</head>

<body>
    <pre id="test-basics" data-line-number=true>
        \begin{algorithm}
        \caption{Test text-style}
        \begin{algorithmic}
        \REQUIRE some preconditions
        \ENSURE some postconditions
        \INPUT some inputs
        \OUTPUT some outputs
        \PROCEDURE{Test-Declarations}{}
            \STATE font families: {\sffamily sffamily, \ttfamily ttfamily, \normalfont normalfont, \rmfamily rmfamily.}
            \STATE font weights: {normal weight, \bfseries bold, \mdseries
            medium, \lfseries lighter. }
            \STATE font shapes: {\itshape itshape \scshape Small-Caps \slshape slshape \upshape upshape.}
            \STATE font sizes: \tiny tiny \scriptsize scriptsize \footnotesize
            footnotesize \small small \normalsize normal \large large \Large Large
            \LARGE LARGE \huge huge \Huge Huge \normalsize
        \ENDPROCEDURE
        \PROCEDURE{Test-Commands}{}
            \STATE \textnormal{textnormal,} \textrm{textrm,} \textsf{textsf,} \texttt{texttt.}
            \STATE \textbf{textbf,} \textmd{textmd,} \textlf{textlf.}
            \STATE \textup{textup,} \textit{textit,} \textsc{textsc,} \textsl{textsl.}
            \STATE \uppercase{uppercase,} \lowercase{LOWERCASE.}
        \ENDPROCEDURE
        \PROCEDURE{Test-Colors}{}
        % feature not implemented
        \ENDPROCEDURE
        \end{algorithmic}
        \end{algorithm}

        \begin{algorithm}
        \caption{Test atoms}
        \begin{algorithmic}
        \STATE \textbf{Specials:} \{ \} \$ \& \# \% \_
        \STATE \textbf{Bools:} \AND \OR \NOT \TRUE \FALSE
        \STATE \textbf{Carriage return:} first line \\ second line
        \STATE \textbf{Text-symbols:} \textbackslash
        \STATE \textbf{Quote-symbols:} `single quotes', ``double quotes''
        \STATE \textbf{Math:} $(\mathcal{C}_m)$, $i \gets i + 1$, $E=mc^2$, \( x^n + y^n = z^n \), $\$$, \(\$\)
        \END{ALGORITHMIC}
        \END{ALGORITHM}
    </pre>
    <pre id="test-codes">
        \begin{algorithm}
        \caption{Test control blocks}
        \begin{algorithmic}
        \PROCEDURE{Test-If}{}
            \IF{&lt;cond&gt;}
                \STATE &lt;block&gt;
            \ELIF{&lt;cond&gt;}
                \STATE &lt;block&gt;
            \ELSE
                \STATE &lt;block&gt;
            \ENDIF
        \ENDPROCEDURE
        \PROCEDURE{Test-For}{$n$}
            \STATE $i \gets 0$
            \FOR{$i < n$}
                \PRINT $i$
                \STATE $i \gets i + 1$
            \ENDFOR
        \ENDPROCEDURE
        \PROCEDURE{Test-For-To}{$n$}
            \STATE $i \gets 0$
            \FOR{$i$ \TO $n$}
                \PRINT $i$
            \ENDFOR
        \ENDPROCEDURE
        \PROCEDURE{Test-For-DownTo}{$n$}
            \FOR{$i \gets n$ \DOWNTO $0$}
                \PRINT $i$
            \ENDFOR
        \ENDPROCEDURE
        \PROCEDURE{Test-For-All}{$n$}
            \FORALL{$i \in \{0, 1, \cdots, n\}$}
                \PRINT $i$
            \ENDFOR
        \ENDPROCEDURE
        \PROCEDURE{Test-While}{$n$}
            \STATE $i \gets 0$
            \WHILE{$i < n$}
                \PRINT $i$
                \STATE $i \gets i + 1$
            \ENDWHILE
        \ENDPROCEDURE
        \PROCEDURE{Test-Repeat}{$n$}
            \STATE $i \gets 0$
            \REPEAT
                \PRINT $i$
                \STATE $i \gets i + 1$
            \UNTIL{$i>n$}
        \ENDPROCEDURE
        \PROCEDURE{Test-Break-Continue}{$n$}
            \FOR{$i = 0$ \TO $2n$}
                \IF{$i < n/2$}
                    \CONTINUE
                \ELIF{$i > n$}
                    \BREAK
                \ENDIF
                \PRINT $i$
            \ENDFOR
        \ENDPROCEDURE
        \end{algorithmic}
        \end{algorithm}
        \begin{algorithm}
        \caption{Test statements and comments}
        \begin{algorithmic}
        \PROCEDURE{Test-Statements}{}
            \STATE This line is a normal statement
            \PRINT \texttt{`this is print statement'}
            \RETURN $retval$
        \ENDPROCEDURE

        \PROCEDURE{Test-Comments}{} \COMMENT{comment for procedure}
            \STATE a statement \COMMENT{inline comment}
            \STATE \COMMENT{line comment}
            \IF{some condition}\COMMENT{comment for if}
                \RETURN \TRUE \COMMENT{another inline comment}
            \ELSE \COMMENT{comment for else}
                \RETURN \FALSE \COMMENT{yet another inline comment}
            \ENDIF
        \ENDPROCEDURE
        \end{algorithmic}
        \end{algorithm}
    </pre>
    <pre id="test-examples" data-title-prefix="Procedure">
        % This quicksort algorithm is extracted from Chapter 7, Introduction
        % to Algorithms (3rd edition)
        \begin{algorithm}
        \caption{Quicksort}
        \begin{algorithmic}
        \PROCEDURE{Quicksort}{$A, p, r$}
            \IF{$p < r$}
                \STATE $q = $ \CALL{Partition}{$A, p, r$}
                \STATE \CALL{Quicksort}{$A, p, q - 1$}
                \STATE \CALL{Quicksort}{$A, q + 1, r$}
            \ENDIF
        \ENDPROCEDURE
        \PROCEDURE{Partition}{$A, p, r$}
            \STATE $x = A[r]$
            \STATE $i = p - 1$
            \FOR{$j = p$ \TO $r - 1$}
                \IF{$A[j] < x$}
                    \STATE $i = i + 1$
                    \STATE exchange
                    $A[i]$ with $A[j]$
                \ENDIF
                \STATE exchange $A[i]$ with $A[r]$
            \ENDFOR
        \ENDPROCEDURE
        \end{algorithmic}
        \end{algorithm}
    </pre>
    <pre id="test-examples-custom-title">
        % This quicksort algorithm is extracted from Chapter 7, Introduction 
        % to Algorithms (3rd edition)
        \begin{algorithm}
        \caption{Quicksort}
        \begin{algorithmic}
        \PROCEDURE{Quicksort}{$A, p, r$}
            \IF{$p < r$} 
                \STATE $q = $ \CALL{Partition}{$A, p, r$}
                \STATE \CALL{Quicksort}{$A, p, q - 1$}
                \STATE \CALL{Quicksort}{$A, q + 1, r$}
            \ENDIF
        \ENDPROCEDURE
        \PROCEDURE{Partition}{$A, p, r$}
            \STATE $x = A[r]$
            \STATE $i = p - 1$
            \FOR{$j = p$ \TO $r - 1$}
                \IF{$A[j] < x$}
                    \STATE $i = i + 1$
                    \STATE exchange
                    $A[i]$ with $A[j]$
                \ENDIF
                \STATE exchange $A[i]$ with $A[r]$
            \ENDFOR
        \ENDPROCEDURE
        \end{algorithmic}
        \end{algorithm}
    </pre>
    <pre class="scopeline-pseudocode" data-line-number=true>
        \begin{algorithm}
        \caption{Classical Euclidean Algorithm}
        \begin{algorithmic}
            \PROCEDURE{Euclid}{$a,b$}
                \WHILE{$a \neq b$}
                    \IF{$a > b$}
                        \STATE $a \gets a - b$
                    \ELSE
                        \STATE $b \gets b - a$
                    \ENDIF
                \ENDWHILE
                \RETURN $a$
            \ENDPROCEDURE
        \end{algorithmic}
        \end{algorithm}
    </pre>
    <pre class="scopeline-pseudocode" data-no-end=true>
        \begin{algorithm}
        \caption{DBSCAN}
        \begin{algorithmic}
        \INPUT A dataset $D$, the $\varepsilon$ distance threshold, and the minimum number of points $minPts$
        \OUTPUT A set of clusters $K$
        \PROCEDURE{DBSCAN}{$D, \varepsilon, minPts$}
            \STATE $K \gets \emptyset$
            \FORALL{$p \in D$}
                \IF{$p$ has not been visited}
                    \STATE mark $p$ as visited
                    \STATE $N_{\varepsilon}(p) \gets $ \textsc{RangeQuery}$(p, \varepsilon, D)$
                    \IF{$N_{\varepsilon}(p) < minPts$}
                        \STATE mark $p$ as noise
                    \ELSE
                        \COMMENT{p is a core object}
                        \STATE $C \gets $ \textsc{ExpandCluster}$(p, N_{\varepsilon}(p))$
                        \STATE $K \gets K \cup \{C\}$
                    \ENDIF
                \ENDIF
            \ENDFOR
            \RETURN $K$
        \ENDPROCEDURE
        \end{algorithmic}
        \end{algorithm}
    </pre>
    <script>
        pseudocode.renderElement(document.getElementById("test-basics"),
                                 {
                                     lineNumber: false,
                                     noEnd: true
                                 });
        pseudocode.renderElement(document.getElementById("test-codes"));
        pseudocode.renderElement(document.getElementById("test-examples"),
                                 {
                                     lineNumber: true,
                                     noEnd: false
                                 });
        pseudocode.renderElement(document.getElementById("test-examples-custom-title"),
                                 {
                                     lineNumber: true,
                                     noEnd: false,
                                     titlePrefix: "My pretty Algorithm"
                                 });                                   
        pseudocode.renderClass("scopeline-pseudocode", { scopeLines: true });
    </script>
</body>
</html>
